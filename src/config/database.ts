import mongoose from 'mongoose';
import config from './env.js';
import logger from './logger.js';

class Database {
  private static instance: Database;
  private isConnected = false;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectInterval = 5000; // 5 seconds

  private constructor() {}

  public static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  public async connect(): Promise<void> {
    if (this.isConnected) {
      logger.info('‚úÖ MongoDB j√° est√° conectado');
      return;
    }

    try {
      // Configura√ß√µes otimizadas para produ√ß√£o
      mongoose.set('strictQuery', false);
      mongoose.set('debug', config.env === 'development');
      
      const connectionOptions = {
        // Configura√ß√µes de timeout e retry
        serverSelectionTimeoutMS: config.mongodb.serverSelectionTimeout || 5000,
        heartbeatFrequencyMS: 10000,
        // Configura√ß√µes de pool de conex√µes
        maxPoolSize: config.mongodb.maxPoolSize || 50,
        minPoolSize: config.mongodb.minPoolSize || 5,
        maxIdleTimeMS: config.mongodb.maxIdleTime || 30000,
        // Configura√ß√µes de buffer
        bufferMaxEntries: 0,
        bufferCommands: false,
        // Configura√ß√µes de compress√£o
        compressors: ['zlib'] as ('zlib' | 'none' | 'snappy' | 'zstd')[],
        // Configura√ß√µes de seguran√ßa
        retryWrites: true,
        w: 'majority' as const,
        readPreference: 'primary' as const,
      };
      
      await mongoose.connect(config.mongodb.uri, connectionOptions);
      
      this.isConnected = true;
      this.reconnectAttempts = 0;
      
      logger.info('‚úÖ MongoDB Atlas conectado com sucesso', {
        database: config.mongodb.database || 'arcsat-production',
        cluster: config.mongodb.cluster || 'arcsat-cluster',
        readyState: mongoose.connection.readyState,
        host: mongoose.connection.host,
      });

      await this.createIndexes();
      await this.validateConnection();

      // Event listeners
      this.setupEventListeners();

      // Graceful shutdown
      this.setupGracefulShutdown();

    } catch (error) {
      logger.error('‚ùå Erro ao conectar ao MongoDB Atlas:', error);
      this.isConnected = false;
      await this.handleReconnection();
      throw error;
    }
  }

  private setupEventListeners(): void {
    mongoose.connection.on('error', (error) => {
      logger.error('‚ùå Erro na conex√£o MongoDB:', error);
      this.isConnected = false;
    });

    mongoose.connection.on('disconnected', () => {
      logger.warn('‚ö†Ô∏è MongoDB desconectado');
      this.isConnected = false;
      this.handleReconnection();
    });

    mongoose.connection.on('reconnected', () => {
      logger.info('üîÑ MongoDB reconectado');
      this.isConnected = true;
      this.reconnectAttempts = 0;
    });

    mongoose.connection.on('close', () => {
      logger.info('üì™ Conex√£o MongoDB fechada');
      this.isConnected = false;
    });
  }

  private async handleReconnection(): Promise<void> {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logger.error(`‚ùå Falha ao reconectar ap√≥s ${this.maxReconnectAttempts} tentativas`);
      return;
    }

    this.reconnectAttempts++;
    
    setTimeout(async () => {
      logger.info(`üîÑ Tentativa de reconex√£o ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
      try {
        await this.connect();
      } catch (error) {
        logger.error(`‚ùå Falha na tentativa de reconex√£o ${this.reconnectAttempts}:`, error);
      }
    }, this.reconnectInterval * this.reconnectAttempts);
  }

  private setupGracefulShutdown(): void {
    const shutdown = async (signal: string) => {
      logger.info(`üì• Recebido sinal ${signal}, fechando conex√£o MongoDB...`);
      await this.disconnect();
      process.exit(0);
    };

    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGQUIT', () => shutdown('SIGQUIT'));
  }

  private async createIndexes(): Promise<void> {
    try {
      logger.info('üî® Criando √≠ndices do banco de dados...');
      
      const db = mongoose.connection.db;
      if (!db) {
        throw new Error('Conex√£o com o banco n√£o est√° dispon√≠vel');
      }
      
      // √çndices para a cole√ß√£o Users
      await db.collection('users').createIndex({ email: 1 }, { unique: true });
      await db.collection('users').createIndex({ companyId: 1 });
      await db.collection('users').createIndex({ email: 1, companyId: 1 });
      await db.collection('users').createIndex({ isActive: 1 });
      
      // √çndices para a cole√ß√£o Companies
      await db.collection('companies').createIndex({ cnpj: 1 }, { unique: true });
      await db.collection('companies').createIndex({ 'subscription.status': 1 });
      await db.collection('companies').createIndex({ 'subscription.plan': 1 });
      
      // √çndices para auditoria e performance
      await db.collection('users').createIndex({ createdAt: 1 });
      await db.collection('companies').createIndex({ createdAt: 1 });
      
      logger.info('‚úÖ √çndices criados com sucesso');
    } catch (error) {
      logger.error('‚ùå Erro ao criar √≠ndices:', error);
    }
  }

  private async validateConnection(): Promise<void> {
    try {
      const db = mongoose.connection.db;
      if (!db) {
        throw new Error('Conex√£o com o banco n√£o est√° dispon√≠vel');
      }
      
      // Teste de conectividade
      await db.admin().ping();
      
      // Verificar permiss√µes b√°sicas
      const collections = await db.listCollections().toArray();
      
      logger.info('‚úÖ Conex√£o validada com sucesso', {
        collections: collections.length,
        state: mongoose.connection.readyState,
      });
    } catch (error) {
      logger.error('‚ùå Falha na valida√ß√£o da conex√£o:', error);
      throw error;
    }
  }

  public async disconnect(): Promise<void> {
    if (!this.isConnected) {
      logger.info('üì™ MongoDB j√° est√° desconectado');
      return;
    }

    try {
      await mongoose.connection.close();
      this.isConnected = false;
      logger.info('üì™ MongoDB desconectado com sucesso');
    } catch (error) {
      logger.error('‚ùå Erro ao desconectar MongoDB:', error);
      throw error;
    }
  }

  public getConnection(): typeof mongoose {
    if (!this.isConnected) {
      throw new Error('MongoDB n√£o est√° conectado. Chame connect() primeiro.');
    }
    return mongoose;
  }

  public isDbConnected(): boolean {
    return this.isConnected && mongoose.connection.readyState === 1;
  }

  public async healthCheck(): Promise<{ status: string; details: Record<string, unknown> }> {
    try {
      const db = mongoose.connection.db;
      if (!db) {
        return { status: 'unhealthy', details: { error: 'Database connection not available' } };
      }

      const ping = await db.admin().ping();
      const stats = await db.stats();
      
      return {
        status: 'healthy',
        details: {
          ping: ping.ok === 1,
          readyState: mongoose.connection.readyState,
          host: mongoose.connection.host,
          name: mongoose.connection.name,
          collections: stats.collections,
          dataSize: stats.dataSize,
          indexes: stats.indexes,
        },
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          readyState: mongoose.connection.readyState,
        },
      };
    }
  }
}

export default Database.getInstance();